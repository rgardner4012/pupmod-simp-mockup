# Manual action to build, sign, and attach a release's RPMs
# ------------------------------------------------------------------------------
#
#             NOTICE: **This file is maintained with puppetsync**
#
# This file is updated automatically as part of a puppet module baseline.
#
# The next baseline sync will overwrite any local changes to this file!
#
# ==============================================================================
#
# This pipeline uses the following GitHub Action Secrets:
#
#   GitHub Secret variable               Notes
#   -------------------------------      ---------------------------------------
#   PUPPETFORGE_API_TOKEN
#   SIMP_CORE_REF_FOR_BUILDING_RPMS      simp-core ref (tag) to use to build
#                                        RPMs with `rake pkg:single`
#   SIMP_DEV_GPG_SIGNING_KEY             GPG signing key's secret key
#   SIMP_DEV_GPG_SIGNING_KEY_ID          User ID (name) of signing key
#   SIMP_DEV_GPG_SIGNING_KEY_PASSPHRASE  Passphrase to use GPG signing key
#
# ------------------------------------------------------------------------------
---
name: 'RELENG: Build + attach RPMs to GitHub Release'

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag"
        required: true
      clobber:
        description: "Clobber assets? (default: no)"
        required: false
        default: no
      clean:
        description: "Wipe existing assets first? (default: no)"
        required: false
        default: no
      dry_run:
        description: "Test build RPMs, but don't update Release (default: no)"
        required: false
        default: no
      target_repo:
        description: "Target repo (instead of this one)"
        required: false
      # FIXME:
      target_repo_token:
        description: "API token for uploading to target repo"
        required: false

env:
  TARGET_REPO: ${{ (github.event.inputs.target_repo != null && format('{0}/{1}', github.repository_owner, github.event.inputs.target_repo)) || github.repository }}
  RELEASE_TAG: ${{ github.event.inputs.release_tag }}
  DRY_RUN: ${{ github.event.inputs.dry_run }}

jobs:
  create-and-attach-rpms-to-github-release:
    name: Build and attach RPMs to Release
    runs-on: ubuntu-20.04
    env:
      target_repo_token: ${{ github.events.inputs.target_repo_token }}
    steps:
      - name: Query info for ${{ env.TARGET_REPO }} release ${{ github.event.inputs.release_tag }}
        id: release-api
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
        run: |
          echo "::warning ::TARGET_REPO: $TARGET_REPO"
          echo "::warning ::RELEASE_TAG: $RELEASE_TAG"

          if ! [[ "$TARGET_REPO" =~ ^[a-z0-9][a-z0-9-]+/[a-z0-9][a-z0-9_-]+$ ]]; then
            printf '::error ::Target repository name has invalid format: %s\n' "$TARGET_REPO"
            exit 88
          fi
          if ! [[ "$RELEASE_TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-(rc|alpha|beta|pre)?([0-9]+)?)?$ ]]; then
            printf '::error ::Release Tag format is not SemVer or SemVer-ish RPM: %s\n' "$RELEASE_TAG"
            exit 88
          fi
          set -e -u -o pipefail
          api_url="${GITHUB_API_URL}/repos/${TARGET_REPO}/releases/tags/${RELEASE_TAG}"
          full_response="$(curl -H "Accept: application/vnd.github.v3+json" "$api_url" | jq .)"

          release_id="$(echo "$full_response" | jq .id )"
          url="$(echo "$full_response" | jq .url )"
          assets_url="$(echo "$full_response" | jq .assets_url )"
          upload_url="$(echo "$full_response" | jq .upload_url )"
          echo "::set-output name=id::${release_id}"
          echo "::set-output name=url::${url}"
          echo "::set-output name=assets_url::${assets_url}"
          echo "::set-output name=upload_url::${upload_url}"
          ###printf '== GITHUB_CONTEXT:\n%s\n' "$GITHUB_CONTEXT"
          ###printf '== release API full_response:\n%s\n' "$full_response"

      - name: Checkout code
        uses: actions/checkout@v2
        with:
          repository: ${{ env.TARGET_REPO }}
          ref: ${{ env.RELEASE_TAG }}
          clean: true
          fetch-depth: 0

      # FIXME: remove when done with testing
      - name: 'MOCK: build-and-sign-rpm'
        id: build-and-sign-rpm
        run: |
          mkdir -p dist
          RPM_GPG_KEY_EXPORT_NAME="${RPM_GPG_KEY_EXPORT_NAME:-RPM-GPG-KEY-SIMP-UNSTABLE-2}"
          wget https://github.com/simp/pupmod-simp-dummy/releases/download/0.3.50/pupmod-simp-dummy-0.3.50-0.noarch.rpm -O dist/x.rpm
          wget https://download.simp-project.com/simp-release-community.rpm -O dist/y.rpm
          wget https://download.simp-project.com/simp/GPGKEYS/RPM-GPG-KEY-SIMP-UNSTABLE-2 -O "dist/${RPM_GPG_KEY_EXPORT_NAME}.pub.asc"
          rpm_file="$(ls -1r dist/*.rpm | head -1)"
          rpm_file_path="$(realpath "$rpm_file")"
          rpm_file_paths="$(find "$PWD/dist" -name \*.rpm)"
          gpg_file="$(find "dist" -name "${RPM_GPG_KEY_EXPORT_NAME}.pub.asc" | head -1)"
          rpm_file_paths_count="$(echo "$rpm_file_paths" | wc -l)"

          rpm_file_paths="${rpm_file_paths//'%'/'%25'}"
          rpm_file_paths="${rpm_file_paths//$'\n'/'%0A'}"
          rpm_file_paths="${rpm_file_paths//$'\r'/'%0D'}"
          echo "::set-output name=rpm_file_paths::$rpm_file_paths"
          echo "::set-output name=rpm_gpg_file::$(realpath "$gpg_file")"
          echo "::set-output name=rpm_dist_dir::$(dirname "$rpm_file_path")"
          echo "::set-output name=rpmassets_url::${assets_url}"
          printf '::error ::MOCKING build-and-sign-rpm; results are NOT real!\n'

###      - name: 'Build & Sign RPMs for ${{ github.event.inputs.release_tag }} Release'
###        # FIXME don't stay on @main unless testing; switch to @v? before release
###        uses: simp/github-action-build-and-sign-pkg-single-rpm@main
###        id: build-and-sign-rpm
###        with:
###          gpg_signing_key: ${{ secrets.SIMP_DEV_GPG_SIGNING_KEY }}
###          gpg_signing_key_id: ${{ secrets.SIMP_DEV_GPG_SIGNING_KEY_ID }}
###          gpg_signing_key_passphrase: ${{ secrets.SIMP_DEV_GPG_SIGNING_KEY_PASSPHRASE }}
###          simp_core_ref_for_building_rpms: ${{ secrets.SIMP_CORE_REF_FOR_BUILDING_RPMS }}


###      - name: Upload RPM file(s) to GitHub Release
###        id: upload_rpm_assets
###        env:
###          GITHUB_TOKEN: ${{ github.event.inputs.target_repo_token || secrets.GITHUB_TOKEN }}
###          rpm_file_paths: ${{ steps.build-and-sign-rpm.outputs.rpm_file_paths }}
###          rpm_gpg_file: ${{ steps.build-and-sign-rpm.outputs.rpm_gpg_file }}
###          upload_url: ${{ steps.release-api.outputs.upload_url }}
###          asset_content_type: application/octet-stream
###        run: |
###          upload_url="$((echo "$upload_url" | sed -e 's/{?.*$//' )"
###          echo "::add-mask::$GITHUB_TOKEN"
###          curl_cmd=(curl -X POST --fail --show-error \
###            --header "Accept: application/vnd.github.v3+json" \
###            --header "Authorization: token ${GITHUB_TOKEN:-default_content_to_cause_error}" \
###          )
###          files=(${rpm_file_paths})
###          echo "== RPM files to upload: ${#files[@]}"
###          echo "== GPG file to upload: ${rpm_gpg_file}"
###
###          if [[ $DRY_RUN == 'yes' ]]; then
###            echo "::warning :: :warning: Dry run enabled: SKIP uploading artifacts"
###          fi
###          # -------------------------------------------------------------------
###
###
###          set -e -u -o pipefail
###          for file in "${files[@]}"; do
###            echo "-- $file"
###            if [ ! -f "$file" ]; then
###              printf '::error ::No file found at $file (got "%s")!\n' "$file"
###              exit 88
###            fi
###            rpm -q --qf '%{NEVRA}' -p "$file" || { echo '::error ::Error reading RPM info from $file'; exit 88; }
###            file_name="$(basename "$file")"
###            full_upload_url="${upload_url}?name=${file_name}"
###            echo
###            echo "== Uploading '$file' to $full_upload_url"
###            file_upload_cmd=(
###              "${curl_cmd[@]}" "$full_upload_url" \
###              --header "Content-Type: ${asset_content_type}" \
###              --data-binary "@${file}" \
###            )
###            "${file_upload_cmd[@]}" | jq .
###          done
###
###          rpm_gpg_file_name="$(basename "$rpm_gpg_file")"
###          full_upload_url="${upload_url}?name=${rpm_gpg_file_name}"
###          if [ ! -f "$rpm_gpg_file" ]; then
###            printf '::error ::No file found at $rpm_gpg_file (got "%s")!\n' "$rpm_gpg_file"
###            exit 88
###          fi
###          echo
###          echo "== Uploading '$rpm_gpg_file' to $full_upload_url == GPG =="
###          asset_content_type='application/pgp-keys'
###          gpg_upload_cmd=(
###             "${curl_cmd[@]}" "$full_upload_url" \
###             --header "Content-Type: ${asset_content_type}" \
###             --data-binary "@${rpm_gpg_file}" \
###          )
###          "${gpg_upload_cmd[@]}" | jq .
###          #upload_reponse_body="$("${gpg_upload_cmd[@]}")"
###          #echo "$upload_reponse_body | jq ."

      - name: 'Upload RPM file(s) to GitHub Release (github-script)'
        id: upload_rpm_assets_ghs
        uses: actions/github-script@v4
        env:
          rpm_file_paths: ${{ steps.build-and-sign-rpm.outputs.rpm_file_paths }}
          rpm_gpg_file: ${{ steps.build-and-sign-rpm.outputs.rpm_gpg_file }}
          release_id:  ${{ steps.release-api.outputs.id }}
          clobber: ${{ github.event.inputs.clobber }}
          clean: ${{ github.event.inputs.clean }}
          dry_run: ${{ github.event.inputs.dry_run }}
        # See:
        #   - https://octokit.github.io/rest.js/
        #   - https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-repository-permissions-for-a-user
        #
        # TODO:
        #   - [ ] Check if asset already exists
        #   - [ ] Delete all existing assets when option exists
        #   - [ ] Clobber all existing assets when option exists
        with:
          github-token: ${{ github.event.inputs.target_repo_token || secrets.GITHUB_TOKEN }}
          script: |
            const path = require('path')
            const fs = require('fs')

            let wipeAssets = async function(owner, repo, release_id ){
              const existingAssets = await github.repos.listReleaseAssets({ owner, repo, release_id })
              console.log( `  !! !! Wiping ALL uploaded assets for ${owner}/${repo} release (id: ${release_id})`)
              console.log( `  $$$$ existingAssets: ${JSON.stringify(existingAssets,null,2)}` )
              existingAssets.data.forEach(async function(asset){
                asset_id = asset.id
                await github.repos.deleteReleaseAsset({ owner, repo, asset_id })
              })
            }

            let clobberAsset = async function(name, owner, repo, release_id ){
              const existingAssets = await github.repos.listReleaseAssets({ owner, repo, release_id })
              const matchingAssets = existingAssets.data.filter(item => item.name == name);
              if ( matchingAssets.length > 0 ){
                asset = matchingAssets[0]
                asset_id = asset.id
                console.log( `  !! !! Clobbering existing asset for ${name} (id: ${asset_id})`)
                await github.repos.deleteReleaseAsset({ owner, repo, asset_id })
              }
            }

            let uploadAsset = async function (owner, repo, release_id, file, assetContentType ){
              const name = path.basename(file)
              const data = fs.readFileSync(file)
              const contentLength = filePath => fs.statSync(filePath).size;
              const headers = {
                'content-type': assetContentType,
                'content-length': contentLength(file)
              };

              console.log(`  -- owner: ${owner}  repo: ${repo}  release_id: ${release_id}` )


              console.log(`  == Uploading asset ${name}: ${assetContentType}`)
              const uploadAssetResponse = await github.repos.uploadReleaseAsset({
                owner, repo, release_id, data, name, headers,
              })
              return( uploadAssetResponse );
            }

            console.log('== start');
            const release_id = process.env.release_id
            const [owner, repo] = process.env.TARGET_REPO.split('/')
            const rpm_files = process.env.rpm_file_paths.split(/[\r\n]+/);
            const rpm_gpg_file = process.env.rpm_gpg_file;
            const clean = process.env.clean == 'yes';
            const clobber = process.env.clobber == 'yes';

            if ( clean ){ await wipeAssets( owner, repo, release_id ) }

            response = await uploadAsset(rpm_gpg_file, 'application/pgp-keys');
            rpm_files.forEach(async function(file){
              const name = path.basename(file)
              if ( clobber ){ await clobberAsset( name, owner, repo, release_id ) }
              await uploadAsset(owner, repo, release_id, file, 'application/octet-stream')
            })
            console.log('== done')



###            const has_write_access = perm_lvl => (perm_lvl == "admin" || perm_lvl == "write" )
###            const write_access_desc = perm_bool => (perm_bool ? "PERMISSION OK" : "PERMISSION DENIED" )
###            if( has_write_access(project_permission.data.permission )){
###              core.setOutput( 'permitted', 'true' )
###            } else {
###              core.setOutput( 'permitted', 'false' )
###              console.log(`::error ::payload user '${context.payload.sender.login}' does not have CI trigger permission for '${context.repository}; not triggering external CI'`)
###            }
###            console.log(`== payload user '${context.payload.sender.login}' CI trigger permission for '${context.repo.owner}': ${write_access_desc(has_write_access(project_permission.data.permission))}`)
